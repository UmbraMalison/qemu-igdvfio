diff --git a/hw/isa/lpc_ich9.c b/hw/isa/lpc_ich9.c
index 19b2198..5a48912 100644
--- a/hw/isa/lpc_ich9.c
+++ b/hw/isa/lpc_ich9.c
@@ -6,6 +6,7 @@
  *               Isaku Yamahata <yamahata at valinux co jp>
  *               VA Linux Systems Japan K.K.
  * Copyright (C) 2012 Jason Baron <jbaron@redhat.com>
+ *		 Andrew Barnes <andy@outsideglobe.com> IGD Support
  *
  * This is based on piix_pci.c, but heavily modified.
  *
@@ -45,7 +46,17 @@
 #include "hw/pci/pci_bus.h"
 #include "exec/address-spaces.h"
 #include "sysemu/sysemu.h"
+#include "hw/pci/pci.h"
+
+#define DEBUG_LPC
+#ifdef DEBUG_LPC
+# define LPC_DPRINTF(format, ...)       printf("LPC: " format, ## __VA_ARGS__)
+#else
+# define LPC_DPRINTF(format, ...)       do { } while (0)
+#endif
 
+/* For intel-spec conforming config */
+#define CORRECT_CONFIG
 static int ich9_lpc_sci_irq(ICH9LPCState *lpc);
 
 /*****************************************************************************/
@@ -53,6 +64,9 @@ static int ich9_lpc_sci_irq(ICH9LPCState *lpc);
 
 static void ich9_lpc_reset(DeviceState *qdev);
 
+/* BEWARE: only set this if you are passing IGD through to guest */
+static bool IGD_PASSTHROUGH = true;
+
 /* chipset configuration register
  * to access chipset configuration registers, pci_[sg]et_{byte, word, long}
  * are used.
@@ -425,7 +439,11 @@ static void ich9_lpc_config_write(PCIDevice *d,
     ICH9LPCState *lpc = ICH9_LPC_DEVICE(d);
     uint32_t rbca_old = pci_get_long(d->config + ICH9_LPC_RCBA);
 
+    LPC_DPRINTF("%s(%04x:%02x:%02x.%x, @0x%x, 0x%x, len=0x%x)\n", __func__,
+            0000, 00, PCI_SLOT(d->devfn),PCI_FUNC(d->devfn), addr, val, len);
+
     pci_default_write_config(d, addr, val, len);
+
     if (ranges_overlap(addr, len, ICH9_LPC_PMBASE, 4)) {
         ich9_lpc_pmbase_update(lpc);
     }
@@ -440,6 +458,34 @@ static void ich9_lpc_config_write(PCIDevice *d,
     }
 }
 
+static uint32_t ich9_lpc_config_read(PCIDevice *d,
+                                 uint32_t addr, int len)
+{
+    uint32_t val;
+
+    if (IGD_PASSTHROUGH)
+    {
+        switch (addr)
+        {
+		    /* It was thought that the intel IGD drivers will check the SVID & SID of LPC for consistency with the IGD */
+            case 0x2c:      /* SVID - Subsystem Vendor Identification */
+            case 0x2e:      /* SID - Subsystem Identificaion */
+                val = host_pci_read_config(0,PCI_SLOT(d->devfn),PCI_FUNC(d->devfn),addr,len);
+                break;
+            default:
+                val = pci_default_read_config(d,addr,len);
+        }
+    }
+    else
+    {
+        val = pci_default_read_config(d,addr,len);
+    }
+    LPC_DPRINTF("%s(%04x:%02x:%02x.%x, @0x%x, len=0x%x) %x\n", __func__,
+        0000, 00, PCI_SLOT(d->devfn),PCI_FUNC(d->devfn), addr, len, val);
+
+    return val;
+}
+
 static void ich9_lpc_reset(DeviceState *qdev)
 {
     PCIDevice *d = PCI_DEVICE(qdev);
@@ -570,6 +616,12 @@ static int ich9_lpc_initfn(PCIDevice *d)
 
     isa_bus = isa_bus_new(&d->qdev, get_system_io());
 
+#ifdef CORRECT_CONFIG
+    pci_set_word(d->wmask + PCI_COMMAND,
+        (PCI_COMMAND_SERR | PCI_COMMAND_PARITY));
+    pci_set_word(d->config + PCI_COMMAND,
+        (PCI_COMMAND_IO | PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER));
+#endif
     pci_set_long(d->wmask + ICH9_LPC_PMBASE,
                  ICH9_LPC_PMBASE_BASE_ADDRESS_MASK);
 
@@ -646,12 +698,22 @@ static void ich9_lpc_class_init(ObjectClass *klass, void *data)
     dc->vmsd = &vmstate_ich9_lpc;
     dc->no_user = 1;
     k->config_write = ich9_lpc_config_write;
+    k->config_read = ich9_lpc_config_read;
     dc->desc = "ICH9 LPC bridge";
-    k->vendor_id = PCI_VENDOR_ID_INTEL;
-    k->device_id = PCI_DEVICE_ID_INTEL_ICH9_8;
-    k->revision = ICH9_A2_LPC_REVISION;
-    k->class_id = PCI_CLASS_BRIDGE_ISA;
 
+    /* For a UN-MODIFIED guest, the following 3 registers need to be read from the host.
+     * alternatively, modify i915_drv.c, intel_detect_pch, add a check for
+     * PCI_DEVICE_ID_INTEL_ICH9_8 and copy the settings from the PCH you desire */
+//    k->vendor_id = PCI_VENDOR_ID_INTEL;
+    k->vendor_id = host_pci_read_config(0,0x1f,0,0x00,2);
+
+//    k->device_id = PCI_DEVICE_ID_INTEL_ICH9_8;
+    k->device_id = host_pci_read_config(0,0x1f,0,0x02,2);
+
+//    k->revision = ICH9_A2_LPC_REVISION;
+    k->revision = host_pci_read_config(0,0x1f,0,0x08,1);
+
+    k->class_id = PCI_CLASS_BRIDGE_ISA;
 }
 
 static const TypeInfo ich9_lpc_info = {
diff --git a/hw/misc/vfio.c b/hw/misc/vfio.c
index fe95e03..d61a11f 100644
--- a/hw/misc/vfio.c
+++ b/hw/misc/vfio.c
@@ -5,6 +5,7 @@
  *
  * Authors:
  *  Alex Williamson <alex.williamson@redhat.com>
+ *  Andrew Barnes <andy@outsideglobe.com> IGD Support
  *
  * This work is licensed under the terms of the GNU GPL, version 2.  See
  * the COPYING file in the top-level directory.
@@ -39,20 +40,54 @@
 #include "qemu/range.h"
 #include "sysemu/kvm.h"
 #include "sysemu/sysemu.h"
+#include "hw/i386/pc.h"
 
-/* #define DEBUG_VFIO */
+#define DEBUG_VFIO
 #ifdef DEBUG_VFIO
-#define DPRINTF(fmt, ...) \
-    do { fprintf(stderr, "vfio: " fmt, ## __VA_ARGS__); } while (0)
+# define DPRINTF(format, ...)       printf("vfio: " format, ## __VA_ARGS__);
 #else
-#define DPRINTF(fmt, ...) \
-    do { } while (0)
+# define DPRINTF(format, ...)       do { } while (0)
 #endif
 
 /* Extra debugging, trap acceleration paths for more logging */
 #define VFIO_ALLOW_MMAP 1
 #define VFIO_ALLOW_KVM_INTX 1
 
+/* A handy list of IGD device ID's */
+#define IS_IGD_HASWELL(id)              (id == 0x0402 \
+                                         || id == 0x0406 \
+                                         || id == 0x040a \
+                                         || id == 0x0412 \
+                                         || id == 0x0416 \
+                                         || id == 0x041a \
+                                         || id == 0x0a04 \
+                                         || id == 0x0a16 \
+                                         || id == 0x0a22 \
+                                         || id == 0x0a26 \
+                                         || id == 0x0a2a )
+#define IS_IGD_IVYBRIDGE(id)		    (id == 0x0162 \
+                                         || id == 0x0166 \
+                                         || id == 0x016a \
+                                         || id == 0x0152 \
+                                         || id == 0x0156 \
+                                         || id == 0x015a )
+#define IS_IGD_SANDYBRIDGE(id)          (id == 0x0102 \
+                                         || id == 0x0106 \
+                                         || id == 0x0112 \
+                                         || id == 0x0116 \
+                                         || id == 0x0122 \
+                                         || id == 0x0126 \
+                                         || id ==0x010a )
+#define IS_IGD_IRONLAKE_CLARKDALE(id)	(id == 0x0042 )
+#define IS_IGD_IRONLAKE_ARRANDALE(id)	(id == 0x0046 )
+#define IS_IGD(id)                      (IS_IGD_IRONLAKE_CLARKDALE(id) \
+                                         || IS_IGD_IRONLAKE_IRONDALE(id) \
+                                         || IS_IGD_SANDYBRIDGE(id) \
+                                         || IS_IGD_IVYBRIDGE(id) \
+                                         || IS_IGD_HASWELL(id) )
+#define IGD_BAR_MASK                    0xFFFFFFFFFFFF0000
+#define DMAR_OPERATION_TIMEOUT          ((s_time_t)((_ms) * 1000000ULL))
+
 struct VFIODevice;
 
 typedef struct VFIOQuirk {
@@ -133,17 +168,25 @@ enum {
 
 struct VFIOGroup;
 
+typedef struct VFIOMemoryListener {
+    MemoryListener listener;
+    bool enabled;
+} VFIOMemoryListener;
+
 typedef struct VFIOContainer {
     int fd; /* /dev/vfio/vfio, empowered by the attached groups */
     struct {
         /* enable abstraction to support various iommu backends */
         union {
-            MemoryListener listener; /* Used by type1 iommu */
+            VFIOMemoryListener listener; /* Used by type1 iommu */
         };
         void (*release)(struct VFIOContainer *);
+        void (*reset)(struct VFIOContainer *);
     } iommu_data;
     QLIST_HEAD(, VFIOGroup) group_list;
     QLIST_ENTRY(VFIOContainer) next;
+    NotifierList pre_mapping; /* IGD QUIRKS - WIP */
+    NotifierList post_mapping; /* IGD QUIRKS - WIP */
 } VFIOContainer;
 
 /* Cache of MSI-X setup plus extra mmap and memory region for split BAR map */
@@ -189,6 +232,9 @@ typedef struct VFIODevice {
     bool has_flr;
     bool has_pm_reset;
     bool needs_reset;
+    MemoryRegion opRegion; /* Intel opregion */
+    Notifier pre_mapping_notifier; /* IGD QUIRKS - WIP */
+    Notifier post_mapping_notifier; /* IGD QUIRKS - WIP */
 } VFIODevice;
 
 typedef struct VFIOGroup {
@@ -214,6 +260,7 @@ static void vfio_pci_write_config(PCIDevice *pdev, uint32_t addr,
                                   uint32_t val, int len);
 static void vfio_mmap_set_enabled(VFIODevice *vdev, bool enabled);
 
+static VFIODevice *igdvfio;
 /*
  * Common VFIO interrupt disable
  */
@@ -1878,6 +1925,92 @@ static void vfio_probe_nvidia_bar0_1800_quirk(VFIODevice *vdev, int nr)
             vdev->host.function);
 }
 
+/* IGD QUIRKS - WIP */
+uint16_t devconfig; // Store device config
+static void igd_preamble(VFIODevice *vdev)
+{
+
+    if (igdvfio == NULL)
+    {
+	DPRINTF("%s igdvfio is null\n", __func__);
+        return;
+    }
+
+    vdev=igdvfio;
+
+    /* The following routine enables bar reads/writes in the real device:*/
+    /* back up the physical config */
+    pread(vdev->fd, &devconfig, 2, vdev->config_offset + PCI_COMMAND);
+
+    // enable MEM in device config
+    uint16_t newconfig=devconfig | PCI_COMMAND_MEMORY;
+    // write new config to device
+    pwrite(vdev->fd,&newconfig,2,vdev->config_offset+PCI_COMMAND);
+
+    DPRINTF("%s \n", __func__);
+
+    // cantiga
+    vfio_bar_read(&vdev->bars[0], 0x2000 + 0x0a4, 4);
+
+    int64_t start_time;
+
+    vfio_bar_write(&vdev->bars[0], 0x2000 + 0x54, 0x000FFFFF, 4);
+    vfio_bar_write(&vdev->bars[0], 0x2000 + 0x700, 0x0, 4);
+
+    start_time = qemu_clock_get_ms(QEMU_CLOCK_REALTIME);
+    while ((vfio_bar_read(&vdev->bars[0], 0x2000 + 0x2AC, 4) & 0xF) != 0)
+    {
+        if ( qemu_clock_get_ms(QEMU_CLOCK_REALTIME) > start_time + 1000)
+        {
+            DPRINTF("%s failed to disable idle handshake\n", __func__);
+            goto finish;
+        }
+        g_usleep(1000000); // relax! don't do it!
+    }
+    DPRINTF("%s succeeded to disable idle handshake\n", __func__);
+
+finish:
+    vfio_bar_write(&vdev->bars[0], 0x2000 + 0x50, 0x10001, 4);
+}
+
+
+static void igd_postamble(VFIODevice *vdev)
+{
+    if (igdvfio == NULL)
+    {
+        return;
+    }
+    vdev=igdvfio;
+
+    DPRINTF("%s \n", __func__);
+
+    vfio_bar_write(&vdev->bars[0], 0x2000 + 0x54, 0xA, 4);
+    vfio_bar_write(&vdev->bars[0], 0x2000 + 0x50, 0x10000, 4);
+
+    // Restore the device config (probably disabling BAR reads/writes)
+    pwrite(vdev->fd,&devconfig,2,vdev->config_offset+PCI_COMMAND);
+}
+
+static void vfio_vga_probe_intel_quirk(VFIODevice *vdev)
+{
+    PCIDevice *pdev = &vdev->pdev;
+
+    DPRINTF("%s\n", __func__);
+
+    if (IS_IGD_SANDYBRIDGE(pci_get_word(pdev->config + PCI_DEVICE_ID)))
+    {
+		/* For IGD QUIRKS. Store the vfio device for later */
+        igdvfio=vdev;
+        DPRINTF("%s Found IGD - adding quirks \n", __func__);
+
+		/* IGD QUIRKS - WIP */
+        vdev->pre_mapping_notifier.notify = igd_preamble;
+        vdev->post_mapping_notifier.notify = igd_postamble;
+
+        notifier_list_add(&vdev->group->container->pre_mapping, &vdev->pre_mapping_notifier);
+        notifier_list_add(&vdev->group->container->post_mapping, &vdev->post_mapping_notifier);
+    }
+}
 /*
  * TODO - Some Nvidia devices provide config access to their companion HDA
  * device and even to their parent bridge via these config space mirrors.
@@ -1891,6 +2024,7 @@ static void vfio_vga_quirk_setup(VFIODevice *vdev)
 {
     vfio_vga_probe_ati_3c3_quirk(vdev);
     vfio_vga_probe_nvidia_3d0_quirk(vdev);
+    vfio_vga_probe_intel_quirk(vdev);
 }
 
 static void vfio_vga_quirk_teardown(VFIODevice *vdev)
@@ -2077,11 +2211,32 @@ static bool vfio_listener_skipped_section(MemoryRegionSection *section)
     return !memory_region_is_ram(section->mr);
 }
 
+/* IGD QUIRKS - WIP */
+static void vfio_listener_begin(MemoryListener *listener)
+{
+    // begin notes the begining of the transaction
+    VFIOContainer *container = container_of(listener, VFIOContainer,
+                                            iommu_data.listener.listener);
+
+    DPRINTF("%s\n",__func__);
+    notifier_list_notify(&container->pre_mapping,NULL);
+}
+
+static void vfio_listener_commit(MemoryListener *listener)
+{
+    // commit notes the completion of the transaction
+    VFIOContainer *container = container_of(listener, VFIOContainer,
+                                            iommu_data.listener.listener);
+
+    DPRINTF("%s\n",__func__);
+    notifier_list_notify(&container->post_mapping,NULL);
+}
+
 static void vfio_listener_region_add(MemoryListener *listener,
                                      MemoryRegionSection *section)
 {
     VFIOContainer *container = container_of(listener, VFIOContainer,
-                                            iommu_data.listener);
+                                            iommu_data.listener.listener);
     hwaddr iova, end;
     void *vaddr;
     int ret;
@@ -2130,7 +2285,7 @@ static void vfio_listener_region_del(MemoryListener *listener,
                                      MemoryRegionSection *section)
 {
     VFIOContainer *container = container_of(listener, VFIOContainer,
-                                            iommu_data.listener);
+                                            iommu_data.listener.listener);
     hwaddr iova, end;
     int ret;
 
@@ -2169,13 +2324,41 @@ static void vfio_listener_region_del(MemoryListener *listener,
 }
 
 static MemoryListener vfio_memory_listener = {
+	/* IGD QUIRKS - WIP */
+//    .begin = vfio_listener_begin,
+//    .commit = vfio_listener_commit,
     .region_add = vfio_listener_region_add,
     .region_del = vfio_listener_region_del,
 };
 
 static void vfio_listener_release(VFIOContainer *container)
 {
-    memory_listener_unregister(&container->iommu_data.listener);
+    memory_listener_unregister(&container->iommu_data.listener.listener);
+    container->iommu_data.listener.enabled = false;
+}
+
+static void vfio_listener_reset(VFIOContainer *container)
+{
+    if (!container->iommu_data.listener.enabled) {
+        memory_listener_register(&container->iommu_data.listener.listener,
+                                 &address_space_memory);
+        container->iommu_data.listener.enabled = true;
+    }
+}
+
+static void vfio_container_release(VFIOContainer *container)
+{
+    if (container->iommu_data.release) {
+        container->iommu_data.release(container);
+    }
+}
+
+static void vfio_container_reset(VFIOContainer *container)
+{
+    if (container->iommu_data.reset) {
+        container->iommu_data.reset(container);
+        container->iommu_data.listener.enabled = true;
+    }
 }
 
 /*
@@ -2510,6 +2693,77 @@ static void vfio_unmap_bars(VFIODevice *vdev)
     }
 }
 
+/* MAP the Intel Op Region. Very Important */
+static void vfio_map_opregion(VFIODevice *vdev)
+{
+    PCIDevice *pdev = &vdev->pdev;
+
+    if (pci_get_word(pdev->config + PCI_VENDOR_ID) != 0x8086)
+    {
+        return;
+    }
+
+    if (IS_IGD_SANDYBRIDGE(pci_get_word(pdev->config + PCI_DEVICE_ID)))
+    {
+        // then we should map the Intel OPRegion
+        DPRINTF("%s\n",__func__);
+
+        int fd;
+        void *guest_opregion;
+        uint32_t host_opregion = (vfio_pci_read_config(pdev,0xfc,4) & ~0xfff);
+        MemoryRegion *guest_memory = get_system_memory();
+
+
+        fd = open("/dev/mem", O_RDWR);
+        guest_opregion = mmap(NULL,0x2000,PROT_READ|PROT_WRITE,MAP_SHARED,fd,host_opregion);
+
+        DPRINTF("%s Map OpRegion: %x\n",__func__,host_opregion);
+
+#ifdef TARGET_I386
+        int ret;
+        /* Tell fw_cfg to notify the BIOS to reserve the range. */
+
+		/* Later XEN code suggests extra reservations in e820. WIP */
+//        ret = e820_add_entry
+//                (0x10000000,host_opregion-0x10000000,E820_RESERVED);
+//        if (ret < 0)
+//        {
+//            DPRINTF("e820_add_entry() table is full\n");
+//        }
+
+//        ret = e820_add_entry(host_opregion,0x3000,E820_NVS);
+//        if (ret < 0)
+//        {
+//            DPRINTF("e820_add_entry() table is full\n");
+//        }
+
+//        ret = e820_add_entry
+//                (host_opregion+0x3000, (uint32_t)-(host_opregion+0x3000), E820_RESERVED);
+//        if (ret < 0)
+//        {
+//            DPRINTF("e820_add_entry() table is full\n");
+//        }
+
+
+		/* Basic reservation */
+        ret = e820_add_entry(host_opregion, 0x2000, E820_NVS);
+        if (ret < 0)
+        {
+            DPRINTF("e820_add_entry() table is full\n");
+        }
+#endif
+
+        memory_region_init_ram_ptr(&vdev->opRegion,
+                                   OBJECT(vdev),
+                                   "vfio-intel-opregion@0xfc",
+                                   0x2000,
+                                   guest_opregion);
+
+        memory_region_add_subregion_overlap
+				(guest_memory,host_opregion,&vdev->opRegion,1);
+    }
+}
+
 /*
  * General setup
  */
@@ -3092,10 +3346,10 @@ static int vfio_connect_container(VFIOGroup *group)
             return -errno;
         }
 
-        container->iommu_data.listener = vfio_memory_listener;
+        container->iommu_data.listener.listener = vfio_memory_listener;
         container->iommu_data.release = vfio_listener_release;
 
-        memory_listener_register(&container->iommu_data.listener, &address_space_memory);
+	container->iommu_data.reset = vfio_listener_reset;
     } else {
         error_report("vfio: No available IOMMU models");
         g_free(container);
@@ -3125,9 +3379,7 @@ static void vfio_disconnect_container(VFIOGroup *group)
     group->container = NULL;
 
     if (QLIST_EMPTY(&container->group_list)) {
-        if (container->iommu_data.release) {
-            container->iommu_data.release(container);
-        }
+	vfio_container_release(container);
         QLIST_REMOVE(container, next);
         DPRINTF("vfio_disconnect_container: close container->fd\n");
         close(container->fd);
@@ -3343,7 +3595,7 @@ static int vfio_get_device(VFIOGroup *group, const char *name, VFIODevice *vdev)
     ret = ioctl(vdev->fd, VFIO_DEVICE_GET_IRQ_INFO, &irq_info);
     if (ret) {
         /* This can fail for an old kernel or legacy PCI dev */
-        DPRINTF("VFIO_DEVICE_GET_IRQ_INFO failure: %m\n");
+        DPRINTF("VFIO_DEVICE_GET_IRQ_INFO failure ret=%d\n", ret);
         ret = 0;
     } else if (irq_info.count == 1) {
         vdev->pci_aer = true;
@@ -3525,6 +3777,10 @@ static int vfio_initfn(PCIDevice *pdev)
         return -ENOENT;
     }
 
+    /* IGD QUIRKS - WIP */
+    notifier_list_init(&group->container->pre_mapping);
+    notifier_list_init(&group->container->post_mapping);
+
     snprintf(path, sizeof(path), "%04x:%02x:%02x.%01x",
             vdev->host.domain, vdev->host.bus, vdev->host.slot,
             vdev->host.function);
@@ -3585,6 +3841,10 @@ static int vfio_initfn(PCIDevice *pdev)
 
     vfio_map_bars(vdev);
 
+    /* Intel Opregion for IGD */
+    vfio_map_opregion(vdev);
+
+
     ret = vfio_add_capabilities(vdev);
     if (ret) {
         goto out_teardown;
@@ -3654,6 +3914,8 @@ static void vfio_pci_reset(DeviceState *dev)
     DPRINTF("%s(%04x:%02x:%02x.%x)\n", __func__, vdev->host.domain,
             vdev->host.bus, vdev->host.slot, vdev->host.function);
 
+    vfio_container_reset(vdev->group->container);
+
     vfio_pci_pre_reset(vdev);
 
     if (vdev->reset_works && (vdev->has_flr || !vdev->has_pm_reset) &&
diff --git a/hw/pci-host/q35.c b/hw/pci-host/q35.c
index c043998..769a069 100644
--- a/hw/pci-host/q35.c
+++ b/hw/pci-host/q35.c
@@ -6,6 +6,7 @@
  *               Isaku Yamahata <yamahata at valinux co jp>
  *               VA Linux Systems Japan K.K.
  * Copyright (C) 2012 Jason Baron <jbaron@redhat.com>
+ *               2013 Andrew Barnes <andy@outsideglobe.com> IGD Support
  *
  * This is based on piix_pci.c, but heavily modified.
  *
@@ -30,11 +31,24 @@
 #include "hw/hw.h"
 #include "hw/pci-host/q35.h"
 #include "qapi/visitor.h"
+#include "hw/pci/pci.h"
 
+#define DEBUG_Q35
+#ifdef DEBUG_Q35
+# define Q35_DPRINTF(format, ...)       printf("Q35: " format, ## __VA_ARGS__)
+#else
+# define Q35_DPRINTF(format, ...)       do { } while (0)
+#endif
+
+/* for intel-spec conforming config */
+#define CORRECT_CONFIG
 /****************************************************************************
  * Q35 host
  */
 
+/* BEWARE: only set this if you are passing IGD through */
+static bool IGD_PASSTHROUGH = true;
+
 static void q35_host_realize(DeviceState *dev, Error **errp)
 {
     PCIHostState *pci = PCI_HOST_BRIDGE(dev);
@@ -288,8 +302,8 @@ static void mch_set_smm(int smm, void *arg)
     memory_region_transaction_commit();
 }
 
-static void mch_write_config(PCIDevice *d,
-                              uint32_t address, uint32_t val, int len)
+static void mch_write_config_default(PCIDevice *d,
+                                        uint32_t address, uint32_t val, int len)
 {
     MCHPCIState *mch = MCH_PCI_DEVICE(d);
 
@@ -312,6 +326,66 @@ static void mch_write_config(PCIDevice *d,
     }
 }
 
+
+static void mch_write_config(PCIDevice *d,
+                              uint32_t address, uint32_t val, int len)
+{
+    if (IGD_PASSTHROUGH)
+    {
+        switch (address)
+        {
+            case 0x58:      /* PAVPC - Protected Audio Video Path Control */
+                host_pci_write_config
+                    (0,PCI_SLOT(d->devfn),PCI_FUNC(d->devfn),address,len,val);
+                break;
+            default:
+                mch_write_config_default(d,address,val,len);
+        }
+    }
+    else
+    {
+        mch_write_config_default(d,address,val,len);
+    }
+}
+
+
+static uint32_t mch_read_config(PCIDevice *d,
+                                 uint32_t address, int len)
+{
+    uint32_t val;
+
+    if (IGD_PASSTHROUGH)
+    {
+        switch (address)
+        {
+            /* According to XEN code, this is all that is requried.
+             * VID,DID,RID are configured in _init method */
+            case 0x2c:		/* SVID - Subsystem Vendor Identification */
+            case 0x2e:      /* SID - Subsystem Identification */
+            case 0x50:      /* GMCH - SNB Graphics Control Register */
+            case 0x52:		/* GMCH - PRE-SNB */
+            case 0xa0:      /* TOM - Top of memory, 8 bytes */
+            case 0xb0:		/* BDSM - Base Data of Stolen Memory (ILK: BSM: Should read from dev2 offset 0x5c) */
+            case 0x58:		/* PAVPC - Protected Audio Video Path Control  */
+            case 0xa4:      /* SNB: Graphics base of stolen memory */
+            case 0xa8:      /* SNB: base of GTT stolen memory */
+                val = host_pci_read_config
+                    (0,PCI_SLOT(d->devfn),PCI_FUNC(d->devfn),address,len);
+                break;
+            default:
+                val = pci_default_read_config(d,address,len);
+        }
+    }
+    else
+    {
+        val = pci_default_read_config(d,address,len);
+    }
+    Q35_DPRINTF("%s(%04x:%02x:%02x.%x, @0x%x, len=0x%x) %x\n", __func__,
+        0000, 00, PCI_SLOT(d->devfn),PCI_FUNC(d->devfn), address, len, val);
+
+    return val;
+}
+
 static void mch_update(MCHPCIState *mch)
 {
     mch_update_pciexbar(mch);
@@ -391,10 +465,75 @@ static int mch_init(PCIDevice *d)
         init_pam(DEVICE(mch), mch->ram_memory, mch->system_memory, mch->pci_address_space,
                  &mch->pam_regions[i+1], PAM_EXPAN_BASE + i * PAM_EXPAN_SIZE,
                  PAM_EXPAN_SIZE);
+
+/* Unsure if this is important. but the following is as per INTEL spec
+ * which otherwise is non-conforming. */
+#ifdef CORRECT_CONFIG
+    /* PCICMD Register */
+    pci_set_word(d->wmask + D0F0_PCICMD,
+                 (D0F0_PCICMD_SERR | D0F0_PCICMD_PERR)); // set writable
+    pci_set_word(d->config + D0F0_PCICMD,
+                 (D0F0_PCICMD_MAE | D0F0_PCICMD_BME)); // set 1
+
+    /* PCISTS Register */
+    pci_set_word(d->w1cmask + D0F0_PCISTS,
+                 (D0F0_PCISTS_DPE | D0F0_PCISTS_SSE | D0F0_PCISTS_RMAS |
+                  D0F0_PCISTS_RTAS | D0F0_PCISTS_DPD));
+    pci_set_word(d->config + D0F0_PCISTS,
+                 (D0F0_PCISTS_CLIST | D0F0_PCISTS_FB2B));
+
+    /* CC Register */
+    /* No RW Registers */
+    //pci_set_byte(d->config + D0F0_CC + D0F0_CC_BCC, 0x06); /* indicating a bridge device */
+
+    /* HDR Register */
+    /* No RW Registers */
+    /* !nnz */
+
+    /* SVID and SID need not be changed */
+
+    /* PXPEPBAR - TODO? */
+    pci_set_quad(d->wmask + D0F0_PXPEPBAR, (D0F0_PXPEPBAR_PXPEPBAR | D0F0_PXPEPBAR_PXPEPBAREN)); // set writable
+
+    /* MCHBAR - TODO? */
+    pci_set_quad(d->wmask + D0F0_MCHBAR, (D0F0_MCHBAR_MCHBAR | D0F0_MCHBAR_MCHBAREN)); // set writable
+
+
+    /* GGC-GMCH */
+    /* RW Registers can be locked by GCCLCK - TODO, assumed RO */
+    //pci_set_word(d->config + D0F0_GGC, (data & (D0F0_GGC_VAMEN | D0F0_GGC_GGMS | D0F0_GGC_GMS | D0F0_GGC_GGCLCK)));
+
+
+    /* DEVEN */
+    pci_set_long(d->wmask + D0F0_DEVEN, D0F0_DEVEN_D0EN);
+    pci_set_long(d->config + D0F0_DEVEN, D0F0_DEVEN_D2EN);
+
+    /* DMIBAR */
+    pci_set_quad(d->wmask + D0F0_DMIBAR, (D0F0_DMIBAR_DMIBAR | D0F0_DMIBAR_DMIBAREN)); // set writable
+
+    /* TOM - Top Of Memory Register */
+    pci_set_quad(d->wmask + D0F0_TOM, (D0F0_TOM_TOM | D0F0_TOM_LOCK ));
+
+    /* TOUUD - Top Of Upper Usable DRAM Register */
+    pci_set_quad(d->wmask + D0F0_TOUUD, (D0F0_TOUUD_TOUUD | D0F0_TOUUD_LOCK ));
+
+    /* BDSM - Base Data of Stolen Memory Register */
+    pci_set_long(d->wmask + D0F0_BDSM, (D0F0_BDSM_BDSM | D0F0_BDSM_LOCK));
+
+    /* BGSM - Base of GTT Stolen Memory Register */
+    pci_set_long(d->wmask + D0F0_BGSM, (D0F0_BGSM_BGSM | D0F0_BGSM_LOCK));
+
+    /* TSEG - G Memory Base Register */
+    pci_set_long(d->wmask + D0F0_TSEG, (D0F0_TSEG_TSEGMB | D0F0_TSEG_LOCK));
+
+    /* TOLUD - Top of Low Usable DRAM */
+    pci_set_long(d->wmask + D0F0_TOLUD, (D0F0_TOLUD_TOLUD | D0F0_TOLUD_LOCK));
+#endif
     }
     return 0;
 }
 
+
 uint64_t mch_mcfg_base(void)
 {
     bool ambiguous;
@@ -412,13 +551,27 @@ static void mch_class_init(ObjectClass *klass, void *data)
 
     k->init = mch_init;
     k->config_write = mch_write_config;
+    k->config_read = mch_read_config;
     dc->reset = mch_reset;
     set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);
     dc->desc = "Host bridge";
     dc->vmsd = &vmstate_mch;
-    k->vendor_id = PCI_VENDOR_ID_INTEL;
-    k->device_id = PCI_DEVICE_ID_INTEL_Q35_MCH;
-    k->revision = MCH_HOST_BRIDGE_REVISION_DEFAULT;
+
+    /* XEN code suggests these values should match the host.
+     * However, it's not that simple because currently seabios expects
+     * either PII3X or Q35.
+     * Further more, I have only found reason for the LPC to match the host
+     * for the PCH identification. No mention about the host-bridge. */
+
+//    k->vendor_id = PCI_VENDOR_ID_INTEL;
+    k->vendor_id = host_pci_read_config(0,0,0,0x00,2);
+
+//    k->device_id = PCI_DEVICE_ID_INTEL_Q35_MCH;
+    k->device_id = host_pci_read_config(0,0,0,0x02,2);
+
+//    k->revision = MCH_HOST_BRIDGE_REVISION_DEFUALT;
+    k->revision = host_pci_read_config(0,0,0,0x08,1);
+
     k->class_id = PCI_CLASS_BRIDGE_HOST;
 }
 
diff --git a/hw/pci/pci.c b/hw/pci/pci.c
index ed32059..f872496 100644
--- a/hw/pci/pci.c
+++ b/hw/pci/pci.c
@@ -2,6 +2,8 @@
  * QEMU PCI bus manager
  *
  * Copyright (c) 2004 Fabrice Bellard
+ * 		Temporarily extended to provide host config read/write.
+ *		Andrew Barnes <andy@outsideglobe.com> IGD Support
  *
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -36,9 +38,9 @@
 #include "hw/pci/msix.h"
 #include "exec/address-spaces.h"
 
-//#define DEBUG_PCI
+#define DEBUG_PCI
 #ifdef DEBUG_PCI
-# define PCI_DPRINTF(format, ...)       printf(format, ## __VA_ARGS__)
+# define PCI_DPRINTF(format, ...)       printf("pci:" format, ## __VA_ARGS__)
 #else
 # define PCI_DPRINTF(format, ...)       do { } while (0)
 #endif
@@ -59,6 +61,81 @@ static Property pci_props[] = {
     DEFINE_PROP_END_OF_LIST()
 };
 
+/* Provides config reads from the host */
+uint32_t host_pci_read_config(int bus, int slot, int fn, uint32_t address, int len)
+{
+    uint32_t val = 0;
+    int fd;
+    int domain = 0;
+    ssize_t ret;
+    char dir[128], name[128];
+
+    snprintf(dir, sizeof(dir), "/sys/bus/pci/devices/%04x:%02x:%02x.%x/",
+             domain, bus, slot, fn);
+    snprintf(name, sizeof(name), "%sconfig", dir);
+
+    fd = open(name, O_RDONLY);
+
+    if (fd >= 0)
+    {
+        do
+        {
+            ret = pread(fd,&val,len,address);
+        } while ((ret < 0) && (errno == EINTR || errno == EAGAIN));
+
+        if (ret != len)
+        {
+            PCI_DPRINTF("%s(%04x:%02x:%02x.%x, @0x%x, len=0x%x) %s ret=%zd error=%d\n",
+                 __func__, 0000, bus, slot, fn, address, len, "pread Failed",ret,errno);
+            val = (1UL << (len * 8)) - 1;
+        }
+    }
+    else
+    {
+        PCI_DPRINTF("%s(%04x:%02x:%02x.%x, @0x%x, len=0x%x) %s\n",
+                 __func__, 0000, bus, slot, fn, address, len, "Open Failed");
+    }
+
+    PCI_DPRINTF("%s(%04x:%02x:%02x.%x, @0x%x, len=0x%x) %x\n",
+                 __func__, 0000, bus, slot, fn, address, len, val);
+    return val;
+}
+
+/* Provides config writes to the host*/
+void host_pci_write_config(int bus, int slot, int fn, uint32_t address, int len, uint32_t val)
+{
+    int fd;
+    int domain = 0;
+    ssize_t ret;
+    char dir[128], name[128];
+
+    snprintf(dir, sizeof(dir), "/sys/bus/pci/devices/%04x:%02x:%02x.%x/",
+             domain, bus, slot, fn);
+    snprintf(name, sizeof(name), "%sconfig", dir);
+
+    fd = open(name, O_RDWR);
+
+    if (fd >= 0)
+    {
+        do
+        {
+            ret = pwrite(fd,&val,len,address);
+        } while ((ret < 0) && (errno == EINTR || errno == EAGAIN));
+
+
+        if (ret != len)
+        {
+            PCI_DPRINTF("%s(%04x:%02x:%02x.%x, @0x%x, len=0x%x) %x %s ret=%zd error=%d\n",
+                 __func__, 0000, bus, slot, fn, address, len, val, "pread Failed",ret,errno);
+        }
+    }
+    else
+    {
+        PCI_DPRINTF("%s(%04x:%02x:%02x.%x, @0x%x, len=0x%x) %s\n",
+                 __func__, 0000, bus, slot, fn, address, len, "Open Failed");
+    }
+}
+
 static void pci_bus_class_init(ObjectClass *klass, void *data)
 {
     BusClass *k = BUS_CLASS(klass);
diff --git a/include/hw/pci-host/q35.h b/include/hw/pci-host/q35.h
index 309065f..1dbdf1b 100644
--- a/include/hw/pci-host/q35.h
+++ b/include/hw/pci-host/q35.h
@@ -86,7 +86,165 @@ typedef struct Q35PCIHost {
 #define MCH_HOST_BRIDGE_CONFIG_DATA            0xcfc
 
 /* D0:F0 configuration space */
-#define MCH_HOST_BRIDGE_REVISION_DEFAULT       0x0
+#define D0F0_VID                               0x00                         /* 16 bits RO */
+#define D0F0_VID_SIZE                          2                            /* 2 Bytes */
+
+
+#define D0F0_DID                               0x02                         /* 16 bits RO */
+#define D0F0_DID_SIZE                          2                            /* 2 Bytes */
+
+
+#define D0F0_PCICMD                            0x04                         /* 16 bits */
+                                                                            /* 15:10 RO RESERVED */
+#define D0F0_PCICMD_FB2B                       0x200                        /* 9 RO=0 Fast back-to-back Enable */
+#define D0F0_PCICMD_SERR                       0x100                        /* 8 RW */
+#define D0F0_PCICMD_ADSTEP                     0x80                         /* 7 RO=0 Address/Data Stepping Enable */
+#define D0F0_PCICMD_PERR                       0x40                         /* 6 RW */
+#define D0F0_PCICMD_VGASNOOP                   0x20                         /* 5 RO=0 VGA Palette Snoop Enable */
+#define D0F0_PCICMD_MWI                        0x10                         /* 4 RO=0 Memory Write and Invalidate Enable */
+                                                                            /* 3 RO RESERVED */
+#define D0F0_PCICMD_BME                        0x04                         /* 2 RO=1 Bus Master Enable */
+#define D0F0_PCICMD_MAE                        0x02                         /* 1 RO=1 Memory Access Enable */
+#define D0F0_PCICMD_IOAE                       0x01                         /* 0 RO=0 I/O Access Enable */
+#define D0F0_PCICMD_SIZE                       2                            /* 2 Bytes */
+
+
+#define D0F0_PCISTS                            0x06                         /* 16 bits */
+#define D0F0_PCISTS_DPE                        0x8000                       /* 15 RW1C Detected Parity Error */
+#define D0F0_PCISTS_SSE                        0x4000                       /* 14 RW1C Signaled System Error */
+#define D0F0_PCISTS_RMAS                       0x2000                       /* 13 RW1C Received Master Abort Status */
+#define D0F0_PCISTS_RTAS                       0x1000                       /* 12 RW1C Reveived Target Abort Status */
+#define D0F0_PCISTS_STAS                       0x800                        /* 11 RO=0 Signaled Target Abort Status */
+#define D0F0_PCISTS_DEVT_MASK                  0x600                        /* 10:9 RO=DEVSEL_FAST DEVSEL Timing */
+#define D0F0_PCISTS_DEVT_FAST                  0x000                        /* DEVSEL_FAST=00 */
+#define D0F0_PCISTS_DPD                        0x100                        /* 8 RW1C Master Data parity Error Detected */
+#define D0F0_PCISTS_FB2B                       0x80                         /* 7 RO=1 Fast Back-to-Back */
+                                                                            /* 6 bitpos RO RESERVED */
+#define D0F0_PCISTS_MC66                       0x20                         /* 5 RO=0 66 MHz Capable */
+#define D0F0_PCISTS_CLIST                      0x10                         /* 4 RO=1 Capability List */
+                                                                            /* 3:0 bitpos RO RESERVED */
+#define D0F0_PCISTS_SIZE                       2                            /* 2 Bytes */
+
+
+#define D0F0_RID                               0x08                         /* 8 bits RO */
+#define D0F0_RID_SIZE                          1                            /* 1 Byte */
+
+
+#define D0F0_CC                                0x09                         /* 24 bits */
+#define D0F0_CC_BCC                            0x800000                     /* 23:16 RO=06 Base Class Code indicating a Bridge Device */
+#define D0F0_CC_SUBCC                          0x8000                       /* 15:8 RO=00 Sub-Class Code indicating a  Host Bridge */
+#define D0F0_CC_PI                             0x80                         /* 7:0 RO=00 Programming Interface */
+#define D0F0_CC_SIZE                           3                            /* 3 Bytes */
+
+
+#define D0F0_HDR                               0x0e                         /* 7:0 RO=00 indicating single function */
+#define D0F0_HDR_SIZE                          1                            /* 1 Byte */
+
+
+#define D0F0_SVID                              0x2c                         /* 15:0 RW-O Subsytem Vendor ID */
+#define D0F0_SVID_SIZE                         2                            /* 2 Bytes */
+
+
+#define D0F0_SID                               0x2e                         /* 15:0 RW-O Subsytem ID */
+#define D0F0_SID_SIZE                          2                            /* 2 Bytes */
+
+
+#define D0F0_PXPEPBAR                          0x40                         /* 64 bits PCI Express Egrees Port Base Address Register */
+                                                                            /* 63:39 RO RESERVED */
+#define D0F0_PXPEPBAR_PXPEPBAR                 Q35_MASK(64, 38, 12)         /* 38:12 RW PXPEPBAR */
+                                                                            /* 11:1 RO RESERVED */
+#define D0F0_PXPEPBAR_PXPEPBAREN               0x01                         /* 0 RW PXPEPBAR Enable */
+#define D0F0_PXPEPBAR_SIZE                     8                            /* 8 Bytes */
+
+
+#define D0F0_MCHBAR                            0x48                         /* 64 bits Host Memory Mapped Register Range Base */
+                                                                            /* 63:39 RO RESERVED */
+#define D0F0_MCHBAR_MCHBAR                     Q35_MASK(64, 38, 15)         /* 38:15 RW MCHBAR */
+                                                                            /* 14:1 RO RESERVED */
+#define D0F0_MCHBAR_MCHBAREN                   0x01                         /* 0 RW MCHBAR Enable */
+#define D0F0_MCHBAR_SIZE                       8                            /* 8 Bytes */
+
+
+#define D0F0_GGC                               0x50                         /* 16 bits GMCH Graphics Control Register */
+                                                                            /* 15 RO RESERVED */
+#define D0F0_GGC_VAMEN                         0x4000                       /* 14 RW-L Versatile Acceleration Mode Enabled */
+                                                                            /* 13:10 RO RESERVED */
+#define D0F0_GGC_GGMS                          0x200                        /* 9:8 RW-L GTT Graphics Memory Size */
+#define D0F0_GGC_GMS                           Q35_MASK(16, 7, 3)           /* 7:3 RW-L Graphics Mode Select */
+                                                                            /* 2 RO RESERVED */
+#define D0F0_GGC_IVD                           0x2                          /* 1 RW-L IGD VGA Disable */
+#define D0F0_GGC_GGCLCK                        0x1                          /* 0 RW-KL GGC Lock */
+#define D0F0_GGC_SIZE                          2                            /* 2 Bytes */
+
+#define D0F0_DEVEN                             0x54                         /* 32 bits Device Enable Register */
+                                                                            /* 31:15 RO RESERVED */
+                                                                            /* 14 RO RESERVED */
+#define D0F0_DEVEN_D6F0EN                      0x2000                       /* 13 RW-L PEG60 Enable */
+                                                                            /* 12:8 RO RESERVED */
+                                                                            /* 7 RO RESERVED */
+                                                                            /* 6:5 RO RESERVED */
+#define D0F0_DEVEN_D2EN                        0x10                         /* 4 RW-L Internal Graphics Engine */
+#define D0F0_DEVEN_D1F0EN                      0x8                          /* 3 RW-L PEG10 Enable */
+#define D0F0_DEVEN_D1F1EN                      0x4                          /* 2 RW-L PEG11 Enable */
+#define D0F0_DEVEN_D1F2EN                      0x2                          /* 1 RW-L PEG12 Enable */
+#define D0F0_DEVEN_D0EN                        0x1                          /* 0 RO=1 Host Bridge */
+#define D0F0_DEVEN_SIZE                        4                            /* 4 Bytes */
+
+
+#define D0F0_PAVPC                             0x58                         /* Protected Audio Video Path Control */
+
+#define D0F0_DMIBAR                            0x68                         /* 64 bits Root Complex Register Range Base Address Register */
+                                                                            /* 63:39 RO RESERVED */
+#define D0F0_DMIBAR_DMIBAR                     Q35_MASK(64, 38, 12)         /* 38:12 DMI Base Address */
+                                                                            /* 11:1 RO RESERVED */
+#define D0F0_DMIBAR_DMIBAREN                   0x01                         /* 0 RW DMIBAR Enable */
+#define D0F0_DMIBAR_SIZE                       8                            /* 8 Bytes */
+
+
+#define D0F0_TOM                               0xa0                         /* 64 bits Top of memory register */
+                                                                            /* 63:39 RO Reserved */
+#define D0F0_TOM_TOM                           Q35_MASK(64,38,20)           /* 38:20 RW-L Top of Memory */
+                                                                            /* 19:1 RO Reserved */
+#define D0F0_TOM_LOCK                          0x1                          /* 0 RW-KL Lock */
+#define D0F0_TOM_SIZE                          8                            /* 8 Bytes */
+
+
+#define D0F0_TOUUD                             0xa8                         /* 64 bits Top of Upper Usable DRAM Register */
+                                                                            /* 63:39 RO Reserved */
+#define D0F0_TOUUD_TOUUD                       Q35_MASK(64,38,20)           /* 38:20 RW-L Top of Upper Usable DRAM Register */
+                                                                            /* 19:1 RO Reserved */
+#define D0F0_TOUUD_LOCK                        0x1                          /* 0 RW-KL Lock */
+#define D0F0_TOUUD_SIZE                        8                            /* 8 Bytes */
+
+
+#define D0F0_BDSM                              0xb0                         /* 32 bits Base Data of Stolen Memory Register */
+#define D0F0_BDSM_BDSM                         Q35_MASK(32,31,20)           /* 31:20 RW-L Graphics Base of Stolen Memory (BDSM) */
+                                                                            /* 19:1 RO Reserved */
+#define D0F0_BDSM_LOCK                         0x1                          /* 0 RW-KL Lock */
+#define D0F0_BDSM_SIZE                         4                            /* 4 Bytes */
+
+
+#define D0F0_BGSM                              0xb4                         /* 32 bits Base of GTT Stolen Memory Register */
+#define D0F0_BGSM_BGSM                         Q35_MASK(32,31,20)           /* 31:20 RW-L Graphics Base of GTT Stolen Memory (BGSM) */
+                                                                            /* 19:1 RO Reserved */
+#define D0F0_BGSM_LOCK                         0x1                          /* 0 RW-KL Lock */
+#define D0F0_BGSM_SIZE                         4                            /* 4 Bytes */
+
+
+#define D0F0_TSEG                              0xb8                         /* 32 bits G Memory Base Register */
+#define D0F0_TSEG_TSEGMB                       Q35_MASK(32,31,20)           /* 31:20 RW-L TSEG Memory Base (TSEGMB) */
+                                                                            /* 19:1 RO Reserved */
+#define D0F0_TSEG_LOCK                         0x1                          /* 0 RW-KL Lock */
+#define D0F0_TSEG_SIZE                         4                            /* 4 Bytes */
+
+
+#define D0F0_TOLUD                             0xbc                         /* 32 bits Top of Low Usable DRAM */
+#define D0F0_TOLUD_TOLUD                       Q35_MASK(32, 31, 20)         /* 31:20 RW-L TOLUD */
+                                                                            /* 19:1 RO RESERVED */
+#define D0F0_TOLUD_LOCK                        0x1                          /* 0 RW-KL Lock */
+#define D0F0_TOLUD_SIZE                        4                            /* 4 Bytes */
+
+#define MCH_HOST_BRIDGE_REVISION_DEFUALT       0x0
 
 #define MCH_HOST_BRIDGE_PCIEXBAR               0x60    /* 64bit register */
 #define MCH_HOST_BRIDGE_PCIEXBAR_SIZE          8       /* 64bit register */
diff --git a/include/hw/pci/pci.h b/include/hw/pci/pci.h
index b783e68..b088bc8 100644
--- a/include/hw/pci/pci.h
+++ b/include/hw/pci/pci.h
@@ -343,6 +343,9 @@ typedef int (*pci_hotplug_fn)(DeviceState *qdev, PCIDevice *pci_dev,
 #define PCI_BUS(obj) OBJECT_CHECK(PCIBus, (obj), TYPE_PCI_BUS)
 #define TYPE_PCIE_BUS "PCIE"
 
+uint32_t host_pci_read_config(int bus, int slot, int fn, uint32_t address, int len);
+void host_pci_write_config(int bus, int slot, int fn, uint32_t address, int len, uint32_t val);
+
 bool pci_bus_is_express(PCIBus *bus);
 bool pci_bus_is_root(PCIBus *bus);
 void pci_bus_new_inplace(PCIBus *bus, size_t bus_size, DeviceState *parent,
diff --git a/include/hw/pci/pci_ids.h b/include/hw/pci/pci_ids.h
index 4c0002b..2dd4532 100644
--- a/include/hw/pci/pci_ids.h
+++ b/include/hw/pci/pci_ids.h
@@ -128,9 +128,13 @@
 #define PCI_DEVICE_ID_INTEL_ICH9_3       0x2913
 #define PCI_DEVICE_ID_INTEL_ICH9_4       0x2914
 #define PCI_DEVICE_ID_INTEL_ICH9_5       0x2919
-#define PCI_DEVICE_ID_INTEL_ICH9_6       0x2930
+//#define PCI_DEVICE_ID_INTEL_ICH9_6       0x2930 /* Q35 QEMU */
+//#define PCI_DEVICE_ID_INTEL_ICH9_6       0x1c22 /* Q67 COUGAR POINT */
+#define PCI_DEVICE_ID_INTEL_ICH9_6       0x8c22 /* HASWELL */
 #define PCI_DEVICE_ID_INTEL_ICH9_7       0x2916
-#define PCI_DEVICE_ID_INTEL_ICH9_8       0x2918
+//#define PCI_DEVICE_ID_INTEL_ICH9_8       0x2918 /* Q35 QEMU */
+//#define PCI_DEVICE_ID_INTEL_ICH9_8       0x1c4e /* Q67 COUGAR POINT */
+#define PCI_DEVICE_ID_INTEL_ICH9_8       0x8c4e /* HASWELL */
 
 #define PCI_DEVICE_ID_INTEL_82801I_UHCI1 0x2934
 #define PCI_DEVICE_ID_INTEL_82801I_UHCI2 0x2935
@@ -142,7 +146,9 @@
 #define PCI_DEVICE_ID_INTEL_82801I_EHCI2 0x293c
 #define PCI_DEVICE_ID_INTEL_82599_SFP_VF 0x10ed
 
-#define PCI_DEVICE_ID_INTEL_Q35_MCH      0x29c0
+//#define PCI_DEVICE_ID_INTEL_Q35_MCH      0x29c0 /* Q35 QEMU */
+//#define PCI_DEVICE_ID_INTEL_Q35_MCH      0x0100 /* Q67 COUGAR POINT */
+#define PCI_DEVICE_ID_INTEL_Q35_MCH      0x0c00 /* HASWELL */
 
 #define PCI_VENDOR_ID_XEN                0x5853
 #define PCI_DEVICE_ID_XEN_PLATFORM       0x0001
